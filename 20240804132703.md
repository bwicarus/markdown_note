from textual import events
from textual.app import App, ComposeResult, Screen
from textual.containers import ScrollableContainer, Container, Horizontal,Grid
from textual.widgets import Button,Static,Select, Input,Markdown,MarkdownViewer,TabbedContent,Switch,TabPane,ProgressBar
import keyboard
from tools import *
from datetime import datetime
import pyperclip
import json
import subprocess
import urllib.parse
import re
import asyncio
###########
import webbrowser
from textual.widgets import MarkdownViewer
###########
config_path = 'C:\\pythonLearn\\setting.json'
with open(config_path, "r", encoding="utf-8") as file:
    config = json.load(file)
db_file_path = "C:\\Users\\setsu\\dist\\DB.db"
db_browser_path = "C:\\Program Files\\DB Browser for SQLite\\DB Browser for SQLite.exe"
anki_path = "C:\\Users\\setsu\\AppData\\Local\\Programs\\Anki\\anki.exe"
###########
card_config="使用␟包裹不同的主题内容和其主题名，并用&&分割主题名和主题内容,参照格式如下(␟主题1标题&&主题1内容␟ ␟主题2标题&&主题2内容␟...),避免格式化回答以外的寒暄。每次的回答都应严格按照这个格式"
markdown_config="使用markdown格式进行排版,将关键词作为各级标题,从四级标题####开始标记"
click_config="将除去主题名以外的所有的名词使用以下格式包裹,示例[异步函数](https://zh.wikipedia.org/wiki/异步函数),如果有外部链接请使用示例:[百度](http://www.baidu.com)的格式"
#language_config="全部使用" + config["language"] + "语言进行交流。"
gpt_configs=card_config+markdown_config+click_config

class Settings(TabPane):#设置页面
    
    def __init__(self):
        super().__init__(title="setting")
        self.id = "setting"
    def compose(self) -> ComposeResult:
        yield Button("close", id="close",classes="close blue")
        modelList=config["modelList"]
        yield Container(Select.from_values(modelList),
                   id="select_model",
                   classes="setting",
                   )
        yield Grid(Select.from_values(config["questionlist"]),
                   id="select_question",
                   classes="setting",
                   )
        
    def on_mount(self) -> None: 
        self.query_one("#select_model").border_title="选择模型"
        self.query_one("#select_question").border_title="选择问题"

    def on_select_changed(self,event:Select.Changed):
        with open(config_path, "w", encoding="utf-8") as file:
            config["model"]=event.select.value
            json.dump(config, file, ensure_ascii=False, indent=4)
            app.model=event.select.value
    def on_button_pressed(self, event: Button.Pressed):
        if event.button.id == "close":
            app.Screen_my.remove_pane(app.Screen_my.active)
        event.stop()
                              
class Screen_anki(TabPane):#用于插入保存屏幕里切换标签栏的页面
    def __init__(self,list,res):
        super().__init__(title="anki"+str(app.loop))
        self.delete_list=[]
        self.sync=False
        self.loop=app.loop
        self.id="anki"+str(app.loop)
        self.lists={}

        for i in range(len(list)):
            self.lists.update({res[i]:list[i]})
    def compose(self) -> ComposeResult:
        yield Horizontal(Button("sync",id="sync",classes="sync"),
                         Button("close",id="close",classes="close blue"),
                         id="ankibuttons",classes="anki_buttons")
        for index,i in enumerate(self.lists.items()):
            yield Grid(Markdown(markdown=i[1][0],id="anki_question_"+str(self.loop)+"_"+str(index)),
                       Markdown(markdown=i[1][1],id="anki_answer_"+str(self.loop)+"_"+str(index)),
                       Button("make",id="ankimake_"+str(self.loop)+"_"+str(index),classes="make Blue"),
                       Button("✕",classes="Purple",id="ankino_"+str(self.loop)+"_"+str(index)),
                       Button("✓",classes="",id="ankiyes_"+str(self.loop)+"_"+str(index)),
                       id="ankigrid_"+str(self.loop)+"_"+str(index),classes="anki_grid",
                       name=i[0]
                       )
        app.loop+=1 
    
    async def on_button_pressed(self, event: Button.Pressed) -> None:
        if event.button.id.startswith("anki"):
            x=event.button.id.split("_")[-1]
            card=self.query_one(f"#ankigrid_{self.loop}_{int(x)}")

        if event.button.id == "sync":
            if self.delete_list==[]:
                pass
            else:
                try:
                    task1=asyncio.create_task(delete_note(self.delete_list))
                    await task1
                except:
                    subprocess.Popen(["start",anki_path],shell=True)
                    task1=asyncio.create_task(delete_note(self.delete_list))
                    await task1
            asyncio.create_task(anki_sync())
            for element in self.query(".no"):
                element.remove()
                self.lists.pop(element.name)
            self.delete_list=[]
            self.sync=True
            if self.lists=={}:
                app.Screen_my.remove_pane(app.Screen_my.active)
            
                
        if event.button.id == "close":
            if self.delete_list==[]:
                pass
            elif self.sync:
                pass
            else:
                try:
                    task1=asyncio.create_task(delete_note(self.delete_list))
                    await task1
                except:
                    subprocess.Popen(["start",anki_path],shell=True)
                    task1=asyncio.create_task(delete_note(self.delete_list))
                    await task1 
            
          
            app.Screen_my.remove_pane(app.Screen_my.active)
        if event.button.id.startswith("ankimake_"):                      
            card.remove()
            self.lists.pop(card.name)
            try:
                res_task = asyncio.create_task(add_note("gpt", [self.lists[card.name]]))
                res = await res_task
            except:
                subprocess.Popen(["start",anki_path],shell=True)
                res_task = asyncio.create_task(add_note("gpt", [self.lists[card.name]]))
                res = await res_task

        if event.button.id.startswith("ankino_"):
            if "pressed" in event.button.classes:
                event.button.remove_class("pressed")
                card.remove_class("no")
                card.remove_class("pressed")
                self.delete_list.remove(card.name)
            else:
                event.button.add_class("pressed")
                card.add_class("no")
                card.add_class("pressed")
                self.delete_list.append(card.name)
            self.sync=False
        if event.button.id.startswith("ankiyes_"):
            card.remove()
            try:
                self.delete_list.remove(card.name)
            except:
                pass
            try:
                self.lists.pop(card.name)
            except:
                pass

class Questions(TabPane):#一个有默认标题的页面插件,并且可以点击按钮进行问题的选择,并且可以设置gpt的system信息,不需要参数
    def __init__(self):
        super().__init__(title="home")
        self.id = "home"
    def compose(self) -> ComposeResult:
        x=1
        config_setting=config["question_setting"]
        config_list=config["questionlist"]
        for key,value in config_list.items():           
            if key==config_setting:
                if key.startswith("_"):
                    yield(Button(key[1:], id=f"question_{x}",name=key,classes="pressed ")  )
                    try:
                        del app.messages[1]
                    except:
                        pass  
                else:
                    yield(Button(key, id=f"question_{x}",name=key,classes="pressed yellow")  )
            else:
                if key.startswith("_"):
                    yield(Button(key[1:], id=f"question_{x}",name=key,classes="yellow")  )
                    try:
                        del app.messages[1]
                    except:
                        pass 
                else:
                    yield(Button(key, id=f"question_{x}",name=key,classes="yellow")  )                     
            x+=1
        yield Button("anki", id="startAnki",classes="anki")

    async def on_button_pressed(self, event: Button.Pressed):
        if event.button.id == "startAnki":
            Bar=ProgressBar(total=100, show_eta=False,id="progress"+str(app.loop),classes="progress")
            await app.mount(Bar)
            message0=app.messages[0]
            self.messages_backup=app.messages
            x=event.button.id.split("_")[-1]
            clipboard=clipboard_reader()
            if clipboard[1]==1:
                answers=clipboard_reader()[0]             
                Github=await OpenGithub(answers)
                Bar.advance(20)
                app.messages.append({"role": "user", "content":"关于这些内容<"+answers+">"+config["anki_setting"] })
                source=answers
            else:
                clipboard_get=await get_clipboard_to_content(datetime.now().strftime("%Y%m%d%H%M%S"))
                answers=clipboard_get[0][0]["image_url"]["url"]
             
                Bar.advance(10)
                Github=await OpenGithub("___\n![图片]("+answers+")")
                app.messages.append({"role": "user", "content":"关于这些内容<"+answers[0]["text"]+">"+config["anki_setting"] })
                Bar.advance(10)
                source="___\n![图片]("+answers[0]["image_url"]["url"]+")"
            
            app.messages[0]={"role": "system", "content":config["anki_setting"]}
            
            task=asyncio.create_task(gpt_get(app.messages,app.model))
            note=await task
            Bar.advance(50)
            app.messages=self.messages_backup
            app.messages.pop()
            app.messages[0]=message0
            
            list=[]
            for char in note.strip().split("␟"):#将gpt返回的数据按照格式保存到列表中
                if char.isspace():
                    continue
                else:
                    char=char.split("&&")
                    if char[0].isspace()and not char[1]:
                        continue
                    elif len(char)>1 and char[1]:
                        list.append([char[0],char[1],source,answers,Github[0]])
                    elif len(char[0])>20 and not char[0].isspace():
                        list.append(["null",char[0],source,answers,Github[0]])           
            try:
                res_task = asyncio.create_task(add_note("gpt", list))
                res = await res_task
            except:
                subprocess.Popen(["start",anki_path],shell=True)
                res_task = asyncio.create_task(add_note("gpt", list))
                res = await res_task
            Bar.advance(30)
            await app.Screen_my.add_pane(Screen_anki(list,res["result"]))
            Bar.remove()
            try:
                app.Screen_my.active="anki"+str(app.loop)
            except:
                pass
            keyboard.send("ctrl+space")
            

        if event.button.id.startswith("question_"):
            with open(config_path, "w", encoding="utf-8") as file:#设置json的默认问题
                question=event.button.name
                config["question_setting"]=question
                json.dump(config, file, ensure_ascii=False, indent=4)
            try:
                self.query(".pressed").remove_class("pressed")
            except:
                pass
            x=1
            for key,value in config["questionlist"].items():
                if x==int(event.button.id.split("_")[-1]):
                    app.question=value
                x+=1
            app.messages[0]={"role": "system", "content":config["questionlist"][config["question_setting"]]+gpt_configs}
            event.button.add_class("pressed")

class Link(MarkdownViewer):#特殊的markdown显示,可以点击链接实现不同的动作

    async def go(self, location):
        if location.startswith('http://') or location.startswith('https://'):
            webbrowser.open(location)
        elif location.startswith('key_'):
            name=urllib.parse.unquote(location[4:  ]).strip("*")
            app.messages.append({"role": "user", "content": name})
            await app.screen_creater(name)
            app.Screen_my.active="screen_"+str(app.loop)
            try:
                app.pop_screen()
                app.uninstall_screen("magnify")
            except:
                pass
            try:
                app.pop_screen()
            except:
                pass

class Answer_card(Static):#基础的查询结果卡片,必须和Screen_new一起使用
    def __init__(self,answer,x,loop):
        self.answer = answer
        self.x=x
        self.get= self.answer[1]
        self.title=self.answer[0]
        self.content=self.answer[2]
        self.loop=loop
        super().__init__(self.content)
    def compose(self) -> ComposeResult:
        
        self.card=Grid(
            Button("+",id=f"button_{self.loop}-{self.x}",classes="button select widget"),
            Button("anki",id=f"anki_{self.loop}-{self.x}",classes="button anki widget"),
            Markdown(markdown=self.content,id=f"markdown_{self.loop}-{self.x}",name=self.content,classes="answers markdown widget"),
            Button("magnify",id=f"magnify_{self.loop}-{self.x}",classes="button  magnify widget"),
            Button("save",id=f"save_{self.loop}-{self.x}",classes="button  save widget"),
            
            classes="answers container",
            id = f"container_{self.loop}-{self.x}",
            name=self.title
            )
        yield self.card

        title=re.search(r'\*{3}(.*?)\*{3}', self.title).group(1) if self.title.startswith(('(', '[')) else self.title

        self.card.border_title=title
    async def on_button_pressed(self, event: Button.Pressed) -> None:
        if event.button.id.startswith("save_"):
            content=self.query_one(f"#markdown_{self.loop}-{self.x}").name
            save_insert(app.time,content,app.messages)
            event.button.add_class("pressed")
        if event.button.id.startswith("magnify_"):#放大按钮
            x=event.button.id.split("_")[-1]
            note=self.query_one(f"#markdown_{self.loop}-{self.x}").name
            app.push_screen(Magnify(note))
        if event.button.id.startswith("button_"):
            x=event.button.id.split("_")[-1]
            note=self.query_one(f"#container_{self.loop}-{self.x}").border_title
            app.messages.append({"role": "user", "content": note})
            asyncio.create_task(app.screen_creater(note))
            app.Screen_my.active="screen_"+str(app.loop)

class Screen_new(TabPane):#基础的查询结果插入页面,必须和Answer_card一起使用,需要的参数分别为answerslist,loop循环数,name标题卡名称,message_content所选择的问题的{}
    def __init__(self,answerslist,loop,name,message_content):
               
        
        
        super().__init__(title=name)
        self.id = "screen_"+str(loop)
        self.answerslist=answerslist
        self.loop=loop
        self.classes="vertical"
        self.message_content=message_content
    def compose(self) -> ComposeResult:
        app.loop+=1
        x=1
        for i in self.answerslist:
            yield Answer_card(i,x,self.loop)
            x+=1
        yield Button("delete",classes="delete",id="delete")           
        keyboard.send("ctrl+space")
    async def on_button_pressed(self, event: Button.Pressed) -> None:
        if event.button.id == "delete":
            if self.loop==0 and app.Screen_my.tab_count==1:
                app.Screen_my.add_pane(Questions())
            else:
                pass
            app.Screen_my.remove_pane(app.Screen_my.active)
            for idex,i in enumerate(app.messages):
                if i==self.message_content:
                    app.messages.remove(i)
                    app.messages.remove(app.messages[idex-1])
                    with open(config_path, "w", encoding="utf-8") as file:
                        config["messages"]=app.messages
                        json.dump(config, file, ensure_ascii=False, indent=4)
        if event.button.id.startswith("Save_"):
            content=self.query_one(f"#markdown_{app.loop}").name
            save_insert(app.time,content,app.messages)

        if event.button.id.startswith("copy"):
            answer=self.query_one(f"#markdown_{app.loop}").name

            pyperclip.copy(answer)

        if event.button.id.startswith("Anki"):
            Bar=ProgressBar(total=100, show_eta=False,id="progress"+str(app.loop),classes="progress")
            await app.mount(Bar)
            message0=app.messages[0]
            self.messages_backup=app.messages
            x=event.button.id.split("_")[-1]                    
            answers=event.button.name
            note_md5=str_to_md5(answers)
            history=messages_to_markdown(app.messages)
            Bar.advance(10)
            Github=await OpenGithub(history)
            app.messages.append({"role": "user", "content":"关于这些内容<"+answers+">"+config["anki_setting"] })
            app.messages[0]={"role": "system", "content":config["anki_setting"]}
            Bar.advance(10)
            task=asyncio.create_task(gpt_get(app.messages,app.model))
            Bar.advance(50)
            note=await task
            
            app.messages=self.messages_backup
            app.messages.pop()
            app.messages[0]=message0
            Bar.advance(10)
            try:
                source=await source_reader(note_md5)[0][0]
            except:
                source="null"
            list=[]
            for char in note.strip().split("␟"):#将gpt返回的数据按照格式保存到列表中
                if char.isspace():
                    continue
                else:
                    char=char.split("&&")
                    if char[0].isspace()and not char[1]:
                        continue
                    elif len(char)>1 and char[1]:
                        list.append([char[0],char[1],source,answers,Github[0]])
                    elif len(char[0])>20 and not char[0].isspace():
                        list.append(["null",char[0],source,answers,Github[0]])
            Bar.advance(10)
            
            try:
                res_task = asyncio.create_task(add_note("gpt", list))
                res = await res_task
            except:
                subprocess.Popen(["start",anki_path],shell=True)
                res_task = asyncio.create_task(add_note("gpt", list))
                res = await res_task
            Bar.advance(10)
            app.Screen_my.add_pane(Screen_anki(list,res["result"]))
            try:
                app.Screen_my.active="anki"+str(self.loop)
            except:
                pass
            Bar.remove()
            keyboard.send("ctrl+space")
            
class Screen_saved(Screen):#基础的保存屏幕
    def __init__(self):
        super().__init__()
        self.answerslist=saved_reader()
        self.input = Input()
        self.classes="saved_screen"
        
    def compose(self) -> ComposeResult:
        self.Screen_saved=ScrollableContainer(id="Screen_saved",classes="tabbed")
        yield Container(
        self.Screen_saved,        
        Grid(
        Button("home", id="home"),
        Button("exit", id="exit",classes="blue"),
        Button("db browser", id="db_brower"),
        id="bottom_buttons"),
        classes="container_saved"   
        )
    def on_mount(self) -> None:
        x=1
        for i in self.answerslist:
            self.Screen_saved.mount(Saved_card(i,x))
            x+=1
        
    async def on_key(self, event: events.Key) -> None:#键盘事件
        if event.key == "enter"and self.input.value:
            app.messages.append({"role": "user", "content": str(self.input.value)})
            question=self.input.value
            asyncio.create_task(app.screen_creater(question))
            self.input.value = ""

    def on_button_pressed(self, event: Button.Pressed):
        if event.button.id == "db_brower":
            try:
                subprocess.Popen([db_browser_path, db_file_path])
            except:
                pass
        if event.button.id == "home":
            self.app.pop_screen()
            self.app.uninstall_screen("saved")

class Saved_card(Static):#在保存页面显示的卡片,按钮和基础的查询结果卡片相比多了一个删除按钮
    def __init__(self,answer,x):
        self.answer = answer
        self.x=x
        self.get= self.answer[1]
        self.title=self.answer[0]
        self.content=self.answer[2]
        super().__init__(self.content)
    def compose(self) -> ComposeResult:      
        self.card=Grid(
            Button("+",id=f"button_{self.x}",classes="button select widget"),
            Button("anki",id=f"anki_{self.x}",classes="button anki widget"),
            Markdown(markdown=self.content,id=f"markdown_{self.x}",name=self.content,classes="answers markdown widget"),
            Button("magnify",id=f"magnify_{self.x}",classes="button  magnify widget"),
            Button("delete",id=f"delete_{self.x}",classes="button  blue widget"),
            
            classes="answers container",
            id = f"container_{self.x}",
            name=self.title
            )
        yield self.card
    def on_mount(self) -> None:
        self.card.border_title=self.title

    async def on_button_pressed(self, event) -> None:
        if event.button.id.startswith("save_"):
            content=self.query_one(f"#markdown_{self.x}").name
            save_insert(app.time,content,app.messages)
            event.button.add_class("pressed")
        if event.button.id.startswith("delete_"):
            content=self.query_one(f"#markdown_{self.x}").name
            delete_saved(content)
            event.button.add_class("pressed")
            self.remove() 
        if event.button.id.startswith("magnify_"):#放大按钮
            x=event.button.id.split("_")[-1]
            note=self.query_one(f"#markdown_{x}").name
            app.push_screen(Magnify_saved(note))

class Magnify(Screen):#基础的卡片放大功能屏幕
    def __init__(self,note):
        super().__init__()
        self.note=note 
        self.mame="magnify"
        self.id="magnify_screen"
        
    def compose(self) -> ComposeResult:
        yield Grid(

            Link(self.note, show_table_of_contents=True, id="magnify_markdown", classes="magnify_markdown"),
            Grid(
            Button("close", id="close",classes="Blue"),
            Button("copy", id="copy"),
            Button("github", id="github",classes="Purple"),
            id="magnify_buttons",
            classes="x3 bottom_buttons",
            ),
            id="magnify_grid",
        )
    

    async def on_button_pressed(self, event: Button.Pressed) -> None:
        if event.button.id == "github":
            result=await OpenGithub(self.note)
            webbrowser.open(result[0])
            event.stop()
        if event.button.id == "copy":
            pyperclip.copy(self.note)
        if event.button.id == "close":
            self.app.pop_screen()
            self.app.uninstall_screen("magnify")  
############保存页面
class Magnify_cards(TabPane):#用于插入保存屏幕里切换标签栏的页面
    def __init__(self,note,titles):
        super().__init__(title=titles,id="magnify_saved"+str(app.loop))
        self.note=note

    def compose(self) -> ComposeResult:
        yield Link(self.note, show_table_of_contents=True, id="markdown_"+str(app.loop), classes="markdown")
        
        yield Grid(Button("delete",classes="delete",id="delete"),
            Button("save",classes="Save",id="Save_"+str(app.loop)),
            Button("copy",classes="copy",id="copy_"+str(app.loop)),
            Button("anki",classes="anki",id="Anki_"+str(app.loop),name=self.note),
            Button("github",classes="github",id="github"),
            classes="save_delete") 
        app.loop+=1

    async def on_button_pressed(self, event: Button.Pressed) -> None:
        if event.button.id == "delete":
            if app.loop==0 or app.Screen_my.tab_count==1:
                app.Screen_my.add_pane(Questions())
                app.messages=[{"role": "system", "content":config["questionlist"][config["question_setting"]]+gpt_configs}]
            else:
                for idex,i in enumerate(app.messages):
                    if self.note in i["content"]:
                        app.messages.remove(i)
                        app.messages.remove(app.messages[idex-1])
            with open(config_path, "w", encoding="utf-8") as file:
                        config["messages"]=app.messages
                        json.dump(config, file, ensure_ascii=False, indent=4)
            app.Screen_my.remove_pane(app.Screen_my.active)                   
        if event.button.id.startswith("Save_"):
            save_insert
        if event.button.id.startswith("copy"):
            pyperclip.copy(self.note)
        if event.button.id.startswith("Anki"):
            Bar=ProgressBar(total=100, show_eta=False,id="progress"+str(app.loop),classes="progress")
            await app.mount(Bar)
            app.mount(Bar)
            message0=app.messages[0]
            self.messages_backup=app.messages
            x=event.button.id.split("_")[-1]                    
            answers=event.button.name
            note_md5=str_to_md5(answers)
            history=messages_to_markdown(app.messages)
            Bar.advance(10)
            Github=await OpenGithub(history)
            Bar.advance(10)
            app.messages.append({"role": "user", "content":"关于这些内容<"+answers+">"+config["anki_setting"] })
            app.messages[0]={"role": "system", "content":config["anki_setting"]}
            task=asyncio.create_task(gpt_get(app.messages,app.model))
            Bar.advance(50)
            note=await task
            app.messages=self.messages_backup
            app.messages.pop()
            app.messages[0]=message0
            try:
                source=await source_reader(note_md5)[0][0]
            except:
                source="null"
            Bar.advance(10)
            list=[]
            for char in note.strip().split("␟"):#将gpt返回的数据按照格式保存到列表中
                if char.isspace():
                    continue
                else:
                    char=char.split("&&")
                    if char[0].isspace()and not char[1]:
                        continue
                    elif len(char)>1 and char[1]:
                        list.append([char[0],char[1],source,answers,Github[0]])
                    elif len(char[0])>20 and not char[0].isspace():
                        list.append(["null",char[0],source,answers,Github[0]])
            
            try:
                res_task = asyncio.create_task(add_note("gpt", list))
                res = await res_task
            except:
                subprocess.Popen(["start",anki_path],shell=True)
                res_task = asyncio.create_task(add_note("gpt", list))
                res = await res_task
            Bar.advance(10)
            app.Screen_my.add_pane(Screen_anki(list,res["result"]))
            Bar.remove()
            try:
                app.Screen_my.active="anki"+str(app.loop)
            except:
                pass
            keyboard.send("ctrl+space")

        if event.button.id == "github":
            result=await OpenGithub(self.note)
            webbrowser.open(result[0])
            event.stop()

class Magnify_saved(Screen):#在保存页面放大屏幕,具有历史记录功能,和一个可以切换的标签栏,以及打开相关的新窗口的能力
    def __init__(self,note):
        super().__init__()
        self.note=note 
        self.mame="magnify"
        self.id="magnify_screen"
        note_md5=str_to_md5(self.note)
        self.history=history_reader(note_md5)
    
    def compose(self):
        self.Screen_saved=TabbedContent(id="tabs_saved",classes="tabbed  saved vertical")
        yield Grid(Button("history", id="history"),
                   Button("github",id="github2"),
            self.Screen_saved,
            Button("close", id="close"),
            Button("copy", id="copy"),
            classes="magnify_screen",
            id="magnify_saved_grid",
        )
    def on_mount(self) -> None:    
        self.Screen_saved.add_pane(Magnify_cards(self.note,"magnify"))
        self.Screen_saved.active="magnify_saved"+str(app.loop)
    async def on_button_pressed(self, event: Button.Pressed) -> None:
        if event.button.id == "copy":
            pyperclip.copy(self.note)
        if event.button.id == "close":
            self.app.pop_screen()
            self.app.uninstall_screen("magnify")
        if event.button.id == "history":
            history_note=messages_to_markdown(eval(str(self.history[0][0])))
            self.Screen_saved.add_pane(Magnify_cards(history_note,"history"))
            self.Screen_saved.active="magnify_saved"+str(app.loop)
        if event.button.id == "github2":
            result=await OpenGithub(self.note)
            webbrowser.open(result[0])
            event.stop()
class MyApp(App):#主程序
    CSS_PATH = "style.css"
    def __init__(self):
        super().__init__()
        self.time=datetime.now().strftime("%Y%m%d%H%M%S")
        clipboard=clipboard_reader()
        if config["clipboard_update"][0]==clipboard:
            self.content=config["clipboard_update"][1]
        else:
            self.content =asyncio.run(get_clipboard_to_content(self.time))
            update("clipboard_update",[clipboard,self.content]) 
        if len(config["messages"])>2:
            self.messages=config["messages"]
        else:
            self.messages=[{"role": "system", "content":config["questionlist"][config["question_setting"]]+gpt_configs},
                           {"role": "user", "content": self.content[0]}]           
        self.input = Input()
        self.source=""
        self.loop=0
        self.saveloop=0
        self.answer=""
        if config["messages_setting"]:
            self.clipboard=""
        else:
            self.clipboard=clipboard
        self.history_note=""
        self.messages_setting=config["messages_setting"]
        self.question="null"
        self.cards=config["cards"]
        self.messages_backup=""
        self.model=config["model"]

    async def screen_creater(self,question):
        #keyboard.send("ctrl+space")
        Bar=ProgressBar(total=100, show_eta=False,id="progress"+str(self.loop),classes="progress")
        await self.mount(Bar)
        Bar.advance(10)
        task=asyncio.create_task(gpt_get(app.messages,self.model))   
        app.answer=await task
        Bar.advance(70)
        message_content={"role": "assistant", "content": app.answer}
        self.messages.append(message_content)
        with open(config_path, "w", encoding="utf-8") as file:
                config["messages"]=self.messages
                json.dump(config, file, ensure_ascii=False, indent=4)             
        answers=Answer(app.answer,question,app.source,app.time) 
        answers.insert()
        answerslist=answers.read(question)
        Bar.advance(10)
        if len(answerslist) in [0, 1]:#如果没有查询结果或者只有一个查询结果,则直接显示markdown,数据来源于gpt查询后保存在APP.answer里           
            try:
                content=str(answerslist[0][2][1:-1].split("&&")[1])
                title=str(answerslist[0][2][1:-1].split("&&")[0])
            except:
                content=answerslist[0][2]
                title=answerslist[0][0]
            app.Screen_my.add_pane(Magnify_cards(content,title))
            app.Screen_my.active="magnify_saved"+str(self.loop)
        else:
            if len(question)>7:
                question=question[:7]+"..."
            self.Screen_my.add_pane(Screen_new(answerslist,self.loop,question,message_content))
            self.Screen_my.active="screen_"+str(self.loop)
        Bar.remove()
        #keyboard.send("ctrl+space")
        self.input.focus()
        self.question=question
    def compose(self) -> ComposeResult:
        self.Screen_my=TabbedContent(id="tabs",classes="tabbed vertical")
        yield Grid(Button("submit", id="submit"),
            Grid(Switch(value=self.messages_setting,classes="title_button switch",id="switch_messages"),
            Button("♪",id="mic",classes="title_button"),
            self.input,
            Button("⿹",id="biger",classes="title_button "),
            Button("◬",id="nail",classes="title_button"),
            Button("⨷", id="exit",classes="title_button"),
            classes="title_buttons"),

        self.Screen_my,

        Grid(
            Button("<", id="left",classes="bottom_button"),
        Button("↺", id="refresh",classes="bottom_button"),
        Button("⁙", id="setting",classes="bottom_button"),
        
        Button("saved", id="saved",classes="purple"),
        Button("＋", id="new",classes="bottom_button"), 
        Button(">", id="right",classes="bottom_button"),
        id="bottom_buttons_begin"),
        classes="App",
        id="App"
        )
        
    def on_mount(self) -> None:
        if len(self.messages)<=2:
            self.Screen_my.add_pane(Questions())
        else:
            self.history_note=messages_to_markdown(self.messages)
            
            self.Screen_my.add_pane(Magnify_cards(self.history_note,"history"))
            self.Screen_my.active="magnify_saved"+str(self.loop)
        self.input.focus()

    def on_input_changed(self) -> None:
        self.bell()  
        
    async def on_button_pressed(self, event: Button.Pressed):
        if event.button.id == "setting":
            try:
                self.Screen_my.add_pane(Settings())
                self.Screen_my.active="setting"
            except:
                self.Screen_my.active="setting"
        

        if event.button.id == "submit":#提交按钮
            if config["question_setting"].startswith("_"):
                if self.input.value:
                    self.messages.append({"role": "user", "content": str(self.input.value)})
                    asyncio.create_task(self.screen_creater(self.input.value))
                else:
                    pass
            else:
                clipboard=clipboard_reader()
                if self.input.value:         
                    if self.clipboard==clipboard:
                        self.messages.append({"role": "user", "content": str(self.input.value)})
                        asyncio.create_task(self.screen_creater(self.input.value))
                    else:
                       
                        if clipboard[1]==1:
                            x="目标文本为"+str(clipboard[0])+"我的问题是:"+self.input.value
                            self.source=self.source+"___\n"+str(clipboard[0])
                        
                        else:
                            
                            x=await get_clipboard_to_content(datetime.now().strftime("%Y%m%d%H%M%S"))
                            x=x[0]
                            
                            x.insert(0,{"type": "text", "text": self.input.value})
                            self.source=self.source+"___\n![图片]("+str(x[1]["image_url"]["url"])+")"
                        self.messages.append({"role": "user", "content": x})
                        asyncio.create_task(self.screen_creater(self.input.value))
                        self.clipboard=clipboard
                        keyboard.send('win+v')
                else:
                    if self.clipboard==clipboard:
                        pass
                    else:
                        y=await get_clipboard_to_content(datetime.now().strftime("%Y%m%d%H%M%S"))
                        self.messages.append({"role": "user", "content": y[0]})
                        if clipboard[1]==1:
                            self.source=self.source+"___\n"+str(clipboard[0])
                        else:
                            self.source=self.source+"___\n![图片]("+str(y[0][0]["image_url"]["url"])+")"
                        asyncio.create_task(self.screen_creater("外部"+str(self.loop)))
                        
                        self.clipboard=clipboard
                        keyboard.send('win+v')
            self.input.value = ""
            
        if event.button.id == "exit":
            with open(config_path, "w", encoding="utf-8") as file:
                config["messages"]=[
            {"null": "null"},
            {"mull": "mull"}
            
            ]   
                config["question_setting"]="默认助手"
                json.dump(config, file, ensure_ascii=False, indent=4)
            keyboard.send('ctrl+shift+w')   

        if event.button.id == "biger":
            keyboard.send("shift+enter")
            if "pressed" in event.button.classes:
                event.button.remove_class("pressed")
            else:
                event.button.add_class("pressed")

        if event.button.id == "nail":
            keyboard.send("ctrl+shift+space")
            if "pressed" in event.button.classes:
                event.button.remove_class("pressed")
            else:
                event.button.add_class("pressed")
            
        if event.button.id.startswith("anki_"):#anki保存动作
            Bar=ProgressBar(total=100, show_eta=False,id="progress"+str(self.loop),classes="progress")
            await self.mount(Bar)
            self.messages_backup=app.messages
            message0=self.messages[0]
            x=event.button.id.split("_")[-1]        
            self.question=self.query_one(f"#container_{x}").name
            answers=self.query_one(f"#markdown_{x}").name
            note_md5=str_to_md5(answers)
            history=messages_to_markdown(self.messages)
            Bar.advance(10)
            Github=await OpenGithub(history)
            Bar.advance(10)
            app.messages.append({"role": "user", "content":"关于我所选择的主题内容<"+self.question+":"+answers+">"+config["anki_setting"] })
            
            app.messages[0]={"role": "system", "content":config["anki_setting"]}

            task=asyncio.create_task(gpt_get(app.messages,self.model))        
            Bar.advance(50)   
            note=await task
            source=await source_reader(note_md5)
            Bar.advance(10)
            source=source[0][0]if source else None
            list=[]
            for char in note.strip().split("␟"):#将gpt返回的数据按照格式保存到列表中
                if char.isspace():
                    continue
                else:
                    char=char.split("&&")
                    if char[0].isspace()and not char[1]:
                        continue
                    elif len(char)>1 and char[1]:
                        list.append([char[0],char[1],source,answers,Github[0]])
                    elif len(char[0])>20 and not char[0].isspace():
                        list.append(["null",char[0],source,answers,Github[0]])

            try:
                res_task = asyncio.create_task(add_note("gpt", list))
                res = await res_task
            except:
                subprocess.Popen(["start",anki_path],shell=True)
                res_task = asyncio.create_task(add_note("gpt", list))
                res = await res_task
            Bar.advance(20)
            self.Screen_my.add_pane(Screen_anki(list,res["result"]))
            Bar.remove()
            self.Screen_my.active="anki"+str(self.loop)            
            app.messages=self.messages_backup
            app.messages.pop()
            app.messages[0]=message0
            #keyboard.send("ctrl+space")
        if event.button.id=="saved":#保存按钮
            self.install_screen(Screen_saved(),name="screen_saved"+str(self.saveloop)  )
            self.push_screen("screen_saved"+str(self.saveloop))
            self.saveloop+=1
        if event.button.id=="new":
            with open(config_path, "w", encoding="utf-8") as file:
                config["messages"]=[
            {"null": "null"},
            {"mull": "mull"}
            
            ]   
                config["question_setting"]="默认助手"
                json.dump(config, file, ensure_ascii=False, indent=4)
            open_new_window()
        if event.button.id=="left":
            keyboard.send("win+left")
        if event.button.id=="right":
            keyboard.send("win+right")
        if event.button.id=="mic":
            keyboard.send("win+h")
            self.input.focus()
        if event.button.id == "biger":
            keyboard.send("F11")
            if "pressed" in event.button.classes:
                event.button.remove_class("pressed")
            else:
                event.button.add_class("pressed")
        if event.button.id == "refresh":
            Bar=ProgressBar(total=100, show_eta=False,id="progress"+str(self.loop),classes="progress")
            await self.mount(Bar)
            if self.Screen_my.active=="home":
               pass 
            else:
                self.messages.pop()

                app.answer=await gpt_get(app.messages,self.model)

                message_content={"role": "assistant", "content": app.answer}
                self.messages.append(message_content)
                with open(config_path, "w", encoding="utf-8") as file:
                    config["messages"]=self.messages
                    json.dump(config, file, ensure_ascii=False, indent=4)#监控用
                answers=Answer(app.answer,self.question,app.source,app.time)
                answers.insert()
                answerslist=answers.read(self.question)
                if len(answerslist) in [0, 1]:#如果没有查询结果或者只有一个查询结果,则直接显示markdown,数据来源于gpt查询后保存在APP.answer里           
                    try:
                        content=str(answerslist[0][2][1:-1].split("&&")[1])
                    except:
                        content=answerslist[0][2]
                        app.Screen_my.add_pane(Magnify_cards(content,"magnify"))
                        app.Screen_my.active="magnify_saved"+str(self.loop)
                        
                else:
                    if len(question)>7:
                        question=question[:7]+"..."
                    self.Screen_my.add_pane(Screen_new(answerslist,self.loop,self.question,message_content))
                    self.Screen_my.active="screen_"+str(self.loop)
                app.Screen_my.remove_pane(app.Screen_my.active)
                
                self.input.focus()
                keyboard.send("ctrl+space")

    async def on_key(self, event: events.Key) -> None:#键盘事件

        if event.key == "enter":
            if self.input.has_focus:

                if config["question_setting"].startswith("_"):
                    if self.input.value:
                        self.messages.append({"role": "user", "content": str(self.input.value)})
                        asyncio.create_task(self.screen_creater(self.input.value))
                    else:
                        pass
                else:
                    clipboard=clipboard_reader()
                    if self.input.value:         
                        if self.clipboard==clipboard:
                            self.messages.append({"role": "user", "content": str(self.input.value)})
                            asyncio.create_task(self.screen_creater(self.input.value))
                        else:
                        
                            if clipboard[1]==1:
                                x="目标文本为"+str(clipboard[0])+"我的问题是:"+self.input.value
                                self.source=self.source+"___\n"+str(clipboard[0])
                            
                            else:
                                
                                x=await get_clipboard_to_content(datetime.now().strftime("%Y%m%d%H%M%S"))
                                x=x[0]
                              
                                x.insert(0,{"type": "text", "text": self.input.value})
                                self.source=self.source+"___\n![图片]("+str(x[1]["image_url"]["url"])+")"
                            self.messages.append({"role": "user", "content": x})
                            asyncio.create_task(self.screen_creater(self.input.value))
                            self.clipboard=clipboard
                            keyboard.send('win+v')
                    else:
                        if self.clipboard==clipboard:
                            pass
                        else:
                            y=await get_clipboard_to_content(datetime.now().strftime("%Y%m%d%H%M%S"))
                            self.messages.append({"role": "user", "content": y[0]})
                            if clipboard[1]==1:
                                self.source=self.source+"___\n"+str(clipboard[0])
                            else:
                                self.source=self.source+"___\n![图片]("+str(y[0][0]["image_url"]["url"])+")"
                            asyncio.create_task(self.screen_creater("外部"+str(self.loop)))
                            
                            self.clipboard=clipboard
                            keyboard.send('win+v')
                self.input.value = ""
            else:
                self.input.focus()
        if event.key == "ctrl+y":
            self.input.focus()

    def on_switch_changed(self, event: Switch.Changed) -> None:
        if event.switch.id == "switch_messages":
            if event.switch.value:
                with open(config_path, "w", encoding="utf-8") as file:
                    config["messages_setting"]=True
                    self.messages_setting=True
                    

                    json.dump(config, file, ensure_ascii=False, indent=4)
                
                self.clipboard="" 
                    
            else:
                with open(config_path, "w", encoding="utf-8") as file:
                    config["messages_setting"]=False

                    self.messages_setting=False
                    json.dump(config, file, ensure_ascii=False, indent=4)
                self.clipboard=clipboard_reader()
            self.input.focus()
            keyboard.send('win+h')
           
    async def on_markdown_link_clicked(self,message:Markdown.LinkClicked)->None:
        if message.href.startswith('http://') or message.href.startswith('https://'):
            webbrowser.open(message.href)
        elif message.href.startswith('key_'):
            name=urllib.parse.unquote(message.href[4:  ]).strip("*")
            self.messages.append({"role": "user", "content": name})
            await self.screen_creater(name)
            
            self.Screen_my.active="screen_"+str(self.loop)
            try:
                self.pop_screen()
                self.uninstall_screen("magnify")
            except:
                pass
            try:
                self.pop_screen()
            except:
                pass
        else:
            pass
if __name__ == "__main__":
    app = MyApp()
    app.run()