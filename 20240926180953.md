# 
___
___
## バブルソート
___
## 
### 冒泡排序
- 

#### 冒泡排序简介
冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的列表，依次比较相邻的两个元素，如果它们的顺序错误就交换它们的位置。遍历列表的工作是重复进行的，直到没有相邻元素需要交换为止。

#### 冒泡排序的步骤
1. 从列表的第一个元素开始，依次比较相邻的两个元素。
2. 如果前一个元素比后一个元素大，则交换它们的位置。
3. 对每一对相邻元素重复上述步骤，直到列表末尾。这时，最大的元素被“冒泡”到列表的最后一位。
4. 忽略列表中最后一个元素，重复上述步骤，直到整个列表有序。

#### 冒泡排序的时间复杂度
- 最佳情况：O(n)（当列表已经有序时）
- 最坏情况：O(n^2)（当列表是逆序时）
- 平均情况：O(n^2)

#### 冒泡排序的代码示例
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        # 提前退出标志
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        # 如果没有发生交换，列表已经有序
        if not swapped:
            break
    return arr

# 示例
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = bubble_sort(arr)
print("排序后的数组:", sorted_arr)
```

#### 冒泡排序的优缺点
**优点：**
- 实现简单，适合初学者理解和使用。
- 对于已经基本有序的列表，效率较高。

**缺点：**
- 时间复杂度较高，效率较低，不适合大规模数据排序。
- 每次只能移动相邻的两个元素，移动速度较慢。

␃
___
## 基本選択法
___
## 
### 选择排序
- 

#### 选择排序简介
选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理是每次从未排序的部分中选出最小（或最大）的元素，将其放到已排序部分的末尾，直到所有元素都排序完毕。

#### 选择排序的步骤
1. 从未排序部分中找到最小（或最大）的元素。
2. 将这个元素与未排序部分的第一个元素交换位置。
3. 重复上述步骤，直到所有元素都排序完毕。

#### 选择排序的时间复杂度
- 最佳情况：O(n^2)
- 最坏情况：O(n^2)
- 平均情况：O(n^2)

#### 选择排序的代码示例
```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        # 假设当前元素是最小的
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        # 交换找到的最小元素和当前元素
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# 示例
arr = [64, 25, 12, 22, 11]
sorted_arr = selection_sort(arr)
print("排序后的数组:", sorted_arr)
```

#### 选择排序的优缺点
**优点：**
- 实现简单，适合初学者理解和使用。
- 不需要额外的内存空间，属于原地排序算法。

**缺点：**
- 时间复杂度较高，效率较低，不适合大规模数据排序。
- 即使列表已经有序，仍然需要进行完整的遍历和交换。

␃
___
## 挿入ソート
___
## 
### 插入排序
- 

#### 插入排序简介
插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

#### 插入排序的步骤
1. 从第一个元素开始，该元素可以认为已经被排序。
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描。
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置。
4. 重复步骤3，直到找到已排序的元素小于或等于新元素的位置。
5. 将新元素插入到该位置后。
6. 重复步骤2~5，直到所有元素均排序完毕。

#### 插入排序的时间复杂度
- 最佳情况：O(n)（当列表已经有序时）
- 最坏情况：O(n^2)（当列表是逆序时）
- 平均情况：O(n^2)

#### 插入排序的代码示例
```python
def insertion_sort(arr):
    n = len(arr)
    for i in range(1, n):
        key = arr[i]
        j = i - 1
        # 将大于key的元素向后移动
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# 示例
arr = [12, 11, 13, 5, 6]
sorted_arr = insertion_sort(arr)
print("排序后的数组:", sorted_arr)
```

#### 插入排序的优缺点
**优点：**
- 实现简单，适合初学者理解和使用。
- 对于已经基本有序的列表，效率较高。
- 稳定排序算法，保持相同元素的相对位置。

**缺点：**
- 时间复杂度较高，效率较低，不适合大规模数据排序。
- 当数据量较大时，插入排序的效率会显著下降。

␃
___
