# 
___
___
## バブルソート
___
## 
### 冒泡排序
- 

#### 冒泡排序简介
冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的列表，依次比较相邻的两个元素，如果它们的顺序错误就交换它们的位置。遍历列表的工作是重复进行的，直到没有相邻元素需要交换为止。

#### 冒泡排序的步骤
1. 从列表的第一个元素开始，依次比较相邻的两个元素。
2. 如果前一个元素比后一个元素大，则交换它们的位置。
3. 对每一对相邻元素重复上述步骤，直到列表末尾。这时，最大的元素被“冒泡”到列表的最后一位。
4. 忽略列表中最后一个元素，重复上述步骤，直到整个列表有序。

#### 冒泡排序的时间复杂度
- 最佳情况：O(n)（当列表已经有序时）
- 最坏情况：O(n^2)（当列表是逆序时）
- 平均情况：O(n^2)

#### 冒泡排序的代码示例
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        # 提前退出标志
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        # 如果没有发生交换，列表已经有序
        if not swapped:
            break
    return arr

# 示例
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = bubble_sort(arr)
print("排序后的数组:", sorted_arr)
```

#### 冒泡排序的优缺点
**优点：**
- 实现简单，适合初学者理解和使用。
- 对于已经基本有序的列表，效率较高。

**缺点：**
- 时间复杂度较高，效率较低，不适合大规模数据排序。
- 每次只能移动相邻的两个元素，移动速度较慢。

␃
___
## 基本選択法
___
## 
### 选择排序
- 

#### 选择排序简介
选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理是每次从未排序的部分中选出最小（或最大）的元素，将其放到已排序部分的末尾，直到所有元素都排序完毕。

#### 选择排序的步骤
1. 从未排序部分中找到最小（或最大）的元素。
2. 将这个元素与未排序部分的第一个元素交换位置。
3. 重复上述步骤，直到所有元素都排序完毕。

#### 选择排序的时间复杂度
- 最佳情况：O(n^2)
- 最坏情况：O(n^2)
- 平均情况：O(n^2)

#### 选择排序的代码示例
```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        # 假设当前元素是最小的
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        # 交换找到的最小元素和当前元素
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# 示例
arr = [64, 25, 12, 22, 11]
sorted_arr = selection_sort(arr)
print("排序后的数组:", sorted_arr)
```

#### 选择排序的优缺点
**优点：**
- 实现简单，适合初学者理解和使用。
- 不需要额外的内存空间，属于原地排序算法。

**缺点：**
- 时间复杂度较高，效率较低，不适合大规模数据排序。
- 即使列表已经有序，仍然需要进行完整的遍历和交换。

␃
___
